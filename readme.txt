	As a JAVA programmer, I hold myself to high standards when it comes to writing code that is not only functional but also elegant and well-organized. That's why, when working on separate scheduling algorithms, I decided to create a class for each of them. By doing so, I was able to achieve a level of cleanliness and structure that made my code easy to read and maintain. I even took things a step further by adding two empty lines between each method across the various scheduling algorithms, which improved the code's overall readability and user-friendliness. As any programmer knows, there's something deeply satisfying about finding patterns and similarities across different coding methods. When working on the four scheduling algorithms, I used a common method for calculating both the average wait time and average turnaround time. By utilizing this method across all four classes, I was able to simplify my code and reduce the risk of errors. But I didn't stop there. To further improve my code's efficiency and user-friendliness, I decided to implement the inputs directly into the code rather than relying on command line inputs. This made my code easier to use for anyone who might be running the program and allowed me to achieve an even higher level of efficiency.


	In the First-Come-First-Serve (FCFS) algorithm, I implemented a calculateWaitTurnaround() method that efficiently computes the wait time and turnaround time by iterating through the burst times and the number of tasks using a for loop. These values are then stored in the waiting time and turnaround time arrays respectively, once the method was called into the Main method. To present the output of the algorithm, I first printed the name of the scheduling algorithm and then used a for loop to generate a clear and concise Gantt chart. After printing the Gantt chart, I call the average wait time and turnaround time method to display the average values. The implementation of the FCFS algorithm was relatively simple, and the use of the calculateWaitTurnaround() method allowed for an efficient calculation of the wait and turnaround times. Overall, the output was presented in an organized and comprehensive manner, providing a clear overview of the scheduling algorithm.


	In the Shortest-Job First (SJF) algorithm code, I utilized a similar form of structure to the FCFS algorithm for calculating the turnaround and waiting time. In the Main method, I created placeholder arrays and used Java's built-in sort method to arrange the burst time in ascending order, so that the shortest job task is executed first. Next, I called the calculateWaitTurnaround() method to fill in the placeholder arrays with the appropriate values. Then, I printed the name of the scheduling algorithm to the console. To arrange the Gantt chart in the correct order, I created a constructor class called TaskNumber(), which sets the task number and burst time to their respective terms. I also created an array list to store each task number with its corresponding burst time, which allows me to access the appropriate task number when printing the Gantt chart. To randomly break ties between tasks with the same burst time, I implemented a comparator method. This method compares two tasks and randomly chooses which task number goes first. To print the Gantt chart to the console, I used a for loop and called the array list into the for loop. Finally, I used the averageWaitTime() and averageTurnaroundTime() methods to complete the code and print the result to the console.


	In the Priority Scheduling algorithm, the structure is similar to the previous two algorithms, with the main difference being the calculateWaitTurnaround() method. This method utilizes a while loop to iterate through each task and its priorities. Within the while loop, a for loop organizes the priorities of each task in the highest to lowest order, followed by an if statement to check if all priorities are in the correct order. If so, an else statement is executed to calculate the waiting time and turnaround time for each task, taking into account their arrival time.  Additionally, the Gantt chart is implemented within the calculateWaitTurnaround() method. This is done using two global variables startTimes and endTimes to keep track of each task's start and finish time, which are calculated during the else statement. To print the Gantt chart to the console, a dummy array is used to organize the task number based on their arrival time and priorities, followed by another for loop to print the chart. The placeholder "TX" is used to denote a gap in the arrival time of the process. One important feature of this code is the implementation of random arrival time, which utilizes Java's built-in random method.


	My Round Robin algorithm follows a similar structure to the previous algorithm, but with some differences in how it calculates waiting time and turnaround time. To calculate these values, I created a method that calculates the service time for each process. The service time method works by iterating over all the tasks in a while loop and checking if any task has remaining burst time. If so, it updates the current task and its start time if necessary. Then, it processes the task for the time quantum or until the task's burst time is fully processed (whichever is smaller), updating the service time accordingly. Once a task is fully processed, its turnaround time is calculated and stored in the turnaround time array. The algorithm continues until all tasks have been fully processed. At that point, any remaining tasks are printed to the Gantt chart, and the program exits the while loop. My code uses a combination of for loops, if-else statements, and built-in functions such as Math.min() to implement the scheduling algorithm. Overall, my code ensures that all tasks are executed in a round-robin fashion for the given time quantum, and the results are presented visually in the form of a Gantt chart